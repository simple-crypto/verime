import json
import re

# Constant attribute to look for.
# Attributed signal will be considered in the file 
# generation
verime_attr = 'verilator_me'

# Check the validity of a signal
def __check_netn_validity(nn):
    return nn[0]!='$'

# Check the validity of a cell
def __check_celn_validity(cn):
    return cn[0]!='$'

def __create_mod_path(mod_path,mod_name):
    if mod_path=='':
        return mod_name
    else:
        return '{}.{}'.format(mod_path,mod_name)

def __create_entry_path_name(mod_path,mod_name,net_name):
    return '{}.{}'.format(
            __create_mod_path(mod_path,mod_name),
            net_name
            )

def __parse_generate_index(netpath):
    idxes = re.findall(r'\[([^]]*)\]',netpath)
    vidx = ''
    for e in idxes:
        vidx += e
    return vidx

def __create_match_entry(mod_path,mod_name,net_name,verime_name):
    # Create the netpath
    np = __create_entry_path_name(mod_path,mod_name,net_name)
    # Create the potential idx string (for Verilog generate blocks)
    idx_str = __parse_generate_index(np)
    if idx_str!='':
        verime_name_ret = verime_name + '__{}'.format(idx_str)
    else:
        verime_name_ret = verime_name
    return [np,verime_name_ret]

def __recur_search_verime_attr(mod_jtree,mod_name,mod_inst,mod_path):
    matches = []
    # Iterate over each netname
    for netn in mod_jtree[mod_name]['netnames'].keys():
        # If the signal is valid (i.e., not for yosys purpose), proceed
        if __check_netn_validity(netn):
            # Search for the target attribute  
            if verime_attr in mod_jtree[mod_name]['netnames'][netn]['attributes'].keys():
                # Create a new match entry
                ment = __create_match_entry(
                        mod_path,
                        mod_inst,
                        netn,
                        mod_jtree[mod_name]['netnames'][netn]['attributes'][verime_attr]
                        )
                matches += [ment]
    
    # Dig into the module cells for other signals in the architecture
    for cn in mod_jtree[mod_name]['cells'].keys():
        if __check_celn_validity(cn):
            matches += __recur_search_verime_attr(
                    mod_jtree,
                    mod_jtree[mod_name]['cells'][cn]['type'],
                    cn,
                    __create_mod_path(mod_path,mod_name)
                    )
    # Return 
    return matches
    
def search_verime_attr(ld_json_netlist,mod_name,mod_inst):
    return __recur_search_verime_attr(ld_json_netlist['modules'],mod_name,mod_inst,'')

# Format the name as generated by Verilator
def __format_cpp_name(netname):
    # Check if the name is from a generated block
    if '[' in netname:
        # Get the signal name
        splitv = netname.split('[')
        sn = splitv[0]
        sn_idx = splitv[1].split(']')[0]
        return "{}__BRA__{}__KET____DOT__".format(
                sn,
                sn_idx
                )
    else:
        return netname

# Create the name of a variable generated by Verilator.
def __create_cpp_cw_name(net_list):
    cw_name = ''
    for e in net_list:
        cw_name += __format_cpp_name(e)
    return cw_name

# Create the list of variables to access a specific signal accross 
# the architecture
def __create_cpp_model_var(netpath):
    # Split path with dot chars
    sp_string = netpath.split(".")
    # Generate the list of variable name 
    var_names = []
    idx_runner = 0
    end = True
    while idx_runner < len(sp_string):
        # Create empty net_list and fill it
        netlist = []
        runi = 0
        if ('[' in sp_string[idx_runner+runi]):
            while ('[' in sp_string[idx_runner+runi]):
                runi += 1
            # Final addition
            runi += 1
        netlist = sp_string[idx_runner:idx_runner+runi+1]
        # Create name
        var_names += [__create_cpp_cw_name(netlist)]
        idx_runner += runi+1
    return var_names 
    
# Create Verilator path from the list of variables
def __create_cpp_model_path(netpath):
    # Create the model header
    mhead_p = "V{}".format(netpath[0])
    # Create the global path that should be called from Verilator
    for e in netpath:
        mhead_p += '->{}'.format(e)
    return mhead_p

# Search top module
def __search_top_module(modules_list):
    for e in modules_list.keys():
        if 'top' in modules_list[e]['attributes'].keys():
            return e

# Create a list of verilator header required for the cpp library.
def __create_cpp_header_list(modules_list):
    # Create an empty list of header
    head_list = []
    # Search for top module
    topm = __search_top_module(modules_list)
    head_list += ['V{}.h'.format(topm)]
    for mn in modules_list.keys():
        head_name = "V{}_{}.h".format(topm,mn)
        head_list += [head_name]
    # Add the Verilated.h header
    head_list += ["verilated.h"]
    return head_list
     

if __name__ == "__main__":
    with open('test.json') as json_file:
        data = json.load(json_file)

    m = search_verime_attr(data,'top','top')

    for e in m:
        print(e[0],'->',e[1])

    print("")

    for e in m:
        print(__create_cpp_model_path(__create_cpp_model_var(e[0])))

    print("")
    
    print(__create_cpp_header_list(data['modules']))

    print("")

    print(len(data['modules']['top']['netnames']['tddloop']['bits']))
